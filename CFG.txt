expr: opAnd SEMICOLON | opAnd SEMICOLON expr | variableDefinition expr | variableDeclaration SEMICOLON expr | assignmentStatement SEMICOLON expr
    | printFunction expr | conditionStatement expr | returnStatement expr | ;

opAnd: opAnd AND opOr | opOr;

opOr: opOr OR opCompare | opCompare;

opCompare: opCompare ISEQUAL opAddOrSub | opCompare SET opAddOrSub | opCompare GET opAddOrSub
	 | opCompare NET opAddOrSub | opCompare ST opAddOrSub | opCompare GT opAddOrSub | opAddOrSub;

opAddOrSub: opAddOrSub PLUS opMultOrDiv | opAddOrSub MINUS opMultOrDiv | opMultOrDiv;

opMultOrDiv: opMultOrDiv MULTIPLY opUnary | opMultOrDiv DIVIDE opUnary | opMultOrDiv REMINDER opUnary | opUnary;

opUnary: PLUS brackets | MINUS brackets | NOT brackets | brackets;

brackets: OPENPARENT opAnd CLOSINGPARENT | dataTypes;

variableDefinition: variableDeclaration EQUAL opAnd SEMICOLON;

variableDeclaration: constWord nameIdentifier;

assignmentStatement: referenceID EQUAL opAddOrSub | dataTypes EQUAL opAddOrSub;

constWord: CONST reservedWord | reservedWord;

reservedWord: KEYWORD;

dataTypes: INT | FLOAT | CHAR | ID;

conditionStatement: ifStatement (elifStatement)* (elseStatement)?;

printFunction: PRINTF OPENPARENT printArg CLOSINGPARENT SEMICOLON;

printArg: (string SEMI ((opAnd | string) SEMI)*(opAnd | string)) | string;

ifStatement: IF OPENPARENT opAnd CLOSINGPARENT OPENBRACKETS body CLOSINGBRACKETS;

elifStatement: ELSE IF OPENPARENT opAnd CLOSINGPARENT OPENBRACKETS body CLOSINGBRACKETS;

elseStatement: ELSE OPENBRACKETS body CLOSINGBRACKETS;

body: expr;

returnStatement: RETURN (opAnd | ) SEMICOLON;